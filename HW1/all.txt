x <- 9:16 ### numeric vector assignement
# x <- c(9, 10, 11, 12, 13, 14, 15, 15) ### alternative assignement
print(tail(x, 3)) ### prints last 3 values
# print(x[(length(x)-2):length(x)]) ### alternative print
print(x[x %% 2 == 0]) ### prints all even vals in x
# print(x[lapply(x, "%%", 2) == 0]) ### overkill alternative
# for (v in x) { if (v %% 2 == 0) { print(v) } } ### unasthetic alternative
x <- x[x %% 2 == 0] ### deletes all even vals in x, also an alt of prior step
print(x)

options(warn=-1)
`%notin%` <- Negate(`%in%`)

n <- as.numeric(readline("Enter a int value for n: ")) # reads user input for n
# the max int is much smmaler than the max numeric, if big set smol
if (!is.na(n)) { if (n > .Machine$integer.max) {
  print("Your n is too large, setting to max R integer value")
  n <- .Machine$integer.max
} }

if (is.na(n)) { while(is.na(n)) {
  n <- as.integer(readline("...An INT value: "))
} }

# summation()
#   option: string containing "for", "while", or "sane" for method selection
summation <- function(option) {
  if (option %notin% c("for", "while", "sane")) {
    print("your option was invalid, defaulting to the sane method" )
    return(sum((1/2)^(1:n)))
  }

  # if adding values smaller than machine epsilon, return sum convergance (1)
  if ((1/2)^n == 0) {
    return(1)
  }

  total <- 0 # # declare total as 0 before summing...

  # # for loop method
  if (option == "for") { for (i in 1:n) {
      total <- total + (1/2)^i
  } }

  # # while loop method (gross)
  if (option == "while") {
    i <- 1 # gross
    while (i <= n) {
      total <- total + (1/2)^i
      i = i + 1
  } }

  # # "analytic" method
  else total <- sum((1/2)^(1:n))

  # # return total
  return(total)
}

print(summation("for"), digits = 17)
print(summation("while"), digits = 17)
print(summation("sane"), digits = 17)

# #
# Error exploration
# #

# # this explores when 1/2^n is approximated as zero
n <- 1
while ((1/2)^n != 0) {
  n <- n + 1
}
print(paste0("Your just adding zeros when you get to ", n))

# # this explores when the sum of 1/2^i is approximated as one
n <- 1
total <- 0
while (total != 1) {
  total <- summation("sane")
  n <- n + 1
}
print(paste0("Your sum approximates to 1 when you get to ", n-1))


duplicateRemover <- function(x) {
  ### internal fucntions
  .merge <- function(r, l) {
    #declares vector size of combined len
    new <- numeric(length(r) + length(l))
    r_j <- l_j <- i <- 1;
    for (i in 1:length(new)) {
        if((r_j <= length(r) && r[r_j] < l[l_j]) || l_j>length(l)) {
          new[i] <- r[r_j]
          r_j <- r_j + 1
        } else {
          new[i] <- l[l_j]
          l_j <- l_j + 1
        }
    }
    return(new)
  }
  .mergeSort <- function(x) {
    # as long as you have more than a single element (important for recursion)
    if(length(x) > 1) {
      # find the midpoint
      cut <- ceiling(length(x)/2)
      # keep recursively dividin up the left and right until you have
      # a single element in each
      r <- .mergeSort(x[1:cut])
      l <- .mergeSort(x[(cut+1):length(x)])
      .merge(r, l)
    } else return(x)
  }

  # if empty or single element you can't have duplicates
  if (length(x) <= 1) return(x)

  # else sort the array using .mergeSort()
  x <- .mergeSort(x)
  print(x)

  # declare vector holding location of items up for deletion...
  x_new <- c()

  # going through each element in x
  for (i in 1:(length(x)-1)) {
    # if the current element isn't equal to the next one, sotre it
    if (x[i] != x[i+1]) {
      x_new <- append(x_new, x[i])
    }
  }
  # we should always save the last one, because if it was a duplicate it wasn't
  # saved anyways...
  x_new <- append(x_new, x[length(x)])
  return(x_new)
}
